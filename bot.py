#!/usr/bin/env python3
# bot_vnstock.py
# Telegram bot using vnstock (best-effort) to build market + per-symbol report and send to Telegram.
# - If vnstock is not installed, the script will emit a MOCK sample message (so you can test formatting).
# - The script attempts multiple candidate function names in vnstock to maximize compatibility.
#
# Usage (GitHub Actions): Set secrets BOT_TOKEN and CHAT_ID in repo settings.
# Optional env:
#   USE_VNSTOCK=1        # enable vnstock calls (if vnstock installed)
#   PCT_ALERT_UP, PCT_ALERT_DOWN, VOL_SURGE_MULT
#
# Requirements (for full functionality):
#   pip install vnstock3 pandas numpy requests yfinance
#
# Author: generated by assistant

import os
import re
import traceback
from datetime import datetime, timedelta

try:
    import requests
except Exception:
    requests = None
import pandas as pd
import numpy as np

# Try to import vnstock (best-effort). Many environments name package vnstock or vnstock3.
vns = None
try:
    import vnstock as vns_mod
    vns = vns_mod
except Exception:
    try:
        import vnstock3 as vns_mod
        vns = vns_mod
    except Exception:
        vns = None

# Configuration / env
BOT_TOKEN = os.getenv("BOT_TOKEN", "").strip()
CHAT_ID   = os.getenv("CHAT_ID", "").strip()
USE_VNSTOCK = os.getenv("USE_VNSTOCK", "1").lower() not in ("0", "false", "no", "")
PCT_ALERT_UP = float(os.getenv("PCT_ALERT_UP", "3.0"))
PCT_ALERT_DOWN = float(os.getenv("PCT_ALERT_DOWN", "-3.0"))
VOL_SURGE_MULT = float(os.getenv("VOL_SURGE_MULT", "2.0"))

# Watchlist
SYMBOLS = ["MBB","HPG","SSI","PVP","KSB","QTP"]

# Helpers
def dbg(msg):
    print(f"[DEBUG] {msg}", flush=True)

def fm_money_million(v):
    """Format money in millions (tri·ªáu)"""
    if v is None:
        return "‚Äî"
    try:
        return f"{v/1_000_000:,.0f} Mn"
    except:
        try:
            return f"{float(v):,.0f}"
        except:
            return str(v)

def fm_shares_million(v):
    if v is None:
        return "‚Äî"
    try:
        return f"{v/1_000_000:,.2f} Mn"
    except:
        try:
            return f"{int(v):,}"
        except:
            return str(v)

def fm_pct(x):
    if x is None:
        return "‚Äî"
    return f"{x:+.2f}%"

def safe_call(obj, candidates, *args, **kwargs):
    """
    Try to call the first available callable from candidates (names) on module/object obj.
    Returns the first non-exception result or raises the last exception.
    """
    last_exc = None
    for name in candidates:
        try:
            func = getattr(obj, name)
            return func(*args, **kwargs)
        except Exception as e:
            last_exc = e
            continue
    if last_exc:
        raise last_exc
    raise AttributeError("No candidate functions found: " + ", ".join(candidates))

# vnstock convenience wrappers ‚Äî attempt multiple function names
def vn_index(index_code="VNINDEX"):
    if vns is None:
        raise RuntimeError("vnstock not available")
    # Try many variant function names/signatures used across vnstock versions.
    names = [
        'stock_historical_data', 'stock_history', 'history', 'get_history',
        'get_index', 'index', 'market_index', 'get_market_index',
    ]
    modules = [vns, getattr(vns, 'stock', None), getattr(vns, 'api', None)]
    last_exc = None
    for mod in modules:
        if not mod:
            continue
        for name in names:
            if not hasattr(mod, name):
                continue
            func = getattr(mod, name)
            try:
                # try common signatures
                try:
                    return func(index_code)
                except TypeError:
                    pass
                try:
                    return func(index_code, '1D', count=60)
                except TypeError:
                    pass
                try:
                    # some variants expect (symbol, start_date, end_date, resolution)
                    end = datetime.now().strftime('%Y-%m-%d')
                    start = (datetime.now() - timedelta(days=60)).strftime('%Y-%m-%d')
                    return func(index_code, start, end, '1D')
                except TypeError:
                    pass
            except Exception as e:
                last_exc = e
                continue
    raise last_exc or RuntimeError('vnstock.index not found')

def vn_quote(symbol):
    if vns is None:
        raise RuntimeError("vnstock not available")
    names = ['stock_quote','stock_latest','quote','get_quote','get_stock_quote','get_latest_price','get_price']
    modules = [vns, getattr(vns, 'stock', None), getattr(vns, 'api', None)]
    last_exc = None
    for mod in modules:
        if not mod:
            continue
        for name in names:
            if not hasattr(mod, name):
                continue
            func = getattr(mod, name)
            try:
                try:
                    return func(symbol)
                except TypeError:
                    # maybe signature (symbol, date) or (symbol, kwargs)
                    try:
                        return func(symbol, datetime.now().strftime('%Y-%m-%d'))
                    except Exception:
                        return func(symbol)
            except Exception as e:
                last_exc = e
                continue
    raise last_exc or RuntimeError('vnstock.quote not found')

def vn_history(symbol, start_date=None, end_date=None, resolution="1D", count=None):
    if vns is None:
        raise RuntimeError("vnstock not available")
    names = ['stock_historical_data','history','get_history','get_historical','get_stock_history','stock_history']
    modules = [vns, getattr(vns, 'stock', None), getattr(vns, 'api', None)]
    last_exc = None
    for mod in modules:
        if not mod:
            continue
        for name in names:
            if not hasattr(mod, name):
                continue
            func = getattr(mod, name)
            try:
                # try common signatures
                # (symbol, start, end, resolution)
                if start_date is None and end_date is None and count is not None:
                    try:
                        return func(symbol, count=count)
                    except TypeError:
                        pass
                try:
                    if start_date is None:
                        # default last N days
                        end = datetime.now().strftime('%Y-%m-%d')
                        start = (datetime.now() - timedelta(days=30)).strftime('%Y-%m-%d')
                    else:
                        start = start_date; end = end_date or datetime.now().strftime('%Y-%m-%d')
                    return func(symbol, start, end, resolution)
                except TypeError:
                    # try simpler signatures
                    try:
                        return func(symbol, resolution)
                    except TypeError:
                        pass
            except Exception as e:
                last_exc = e
                continue
    raise last_exc or RuntimeError('vnstock.history not found')

def vn_foreign(symbol=None):
    if vns is None:
        raise RuntimeError("vnstock not available")
    names = ['stock_top_foreign_trade','top_foreign_trade','foreign_trade','top_foreign','foreign_flow','foreign']
    modules = [vns, getattr(vns, 'stock', None), getattr(vns, 'api', None)]
    last_exc = None
    for mod in modules:
        if not mod:
            continue
        for name in names:
            if not hasattr(mod, name):
                continue
            func = getattr(mod, name)
            try:
                if symbol:
                    try:
                        return func(symbol)
                    except TypeError:
                        return func(symbol=symbol)
                else:
                    try:
                        return func()
                    except TypeError:
                        # maybe requires date
                        return func(datetime.now().strftime('%Y-%m-%d'))
            except Exception as e:
                last_exc = e
                continue
    raise last_exc or RuntimeError('vnstock.foreign not found')

def vn_price_board(symbol):
    if vns is None:
        raise RuntimeError("vnstock not available")
    names = ['price_board','orderbook','get_orderbook','get_price_board','priceboard']
    modules = [vns, getattr(vns, 'stock', None), getattr(vns, 'api', None)]
    last_exc = None
    for mod in modules:
        if not mod:
            continue
        for name in names:
            if not hasattr(mod, name):
                continue
            func = getattr(mod, name)
            try:
                try:
                    return func([symbol])
                except TypeError:
                    return func(symbol)
            except Exception as e:
                last_exc = e
                continue
    raise last_exc or RuntimeError('vnstock.price_board not found')

# Compute indicators from history df (pandas DataFrame with 'close', 'volume', 'high', 'low' cols)
def indicators_from_history(df):
    out = {}
    if df is None or df.empty:
        return out
    # adapt column names
    cols = {c.lower():c for c in df.columns}
    # ensure Close column
    if any(k in cols for k in ('close','close_price','last')):
        close_col = cols.get('close') or cols.get('close_price') or cols.get('last')
    else:
        return out
    close = df[close_col].astype(float).dropna()
    out['last'] = float(close.iloc[-1])
    out['prev'] = float(close.iloc[-2]) if len(close)>=2 else out['last']
    out['pct'] = (out['last']/out['prev'] - 1)*100 if out['prev']!=0 else 0.0
    for n in (20,50,200):
        if len(close) >= n:
            out[f'sma{n}'] = float(close.rolling(n).mean().iloc[-1])
        else:
            out[f'sma{n}'] = None
    # avg vol20
    vol_col = None
    for k in ('volume','vol','nmvol'):
        if k in cols:
            vol_col = cols[k]; break
    if vol_col and len(df[vol_col].dropna())>=20:
        vol = df[vol_col].astype(float).fillna(0)
        out['avgvol20'] = float(vol.rolling(20).mean().iloc[-1])
        out['vol'] = float(vol.iloc[-1])
        out['vol_ratio'] = out['vol']/out['avgvol20'] if out['avgvol20'] else None
    else:
        out['avgvol20']=out['vol']=out['vol_ratio']=None
    # ATR14 if high/low present
    high_col = cols.get('high'); low_col = cols.get('low')
    if high_col and low_col and len(df)>=15:
        high = df[high_col].astype(float)
        low = df[low_col].astype(float)
        cshift = df[close_col].astype(float).shift(1)
        tr = pd.concat([high-low, (high-cshift).abs(), (low-cshift).abs()], axis=1).max(axis=1).dropna()
        out['atr14'] = float(tr.rolling(14).mean().iloc[-1]) if len(tr)>=14 else None
    else:
        out['atr14'] = None
    return out

# Build report using vnstock when available, otherwise mock sample
def build_report():
    now = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    lines = []
    lines.append(f"üìä B√°o c√°o th·ªã tr∆∞·ªùng ‚Äî {now}")
    # Part 1 - market summary
    if vns is None or not USE_VNSTOCK:
        dbg("vnstock not available or disabled ‚Äî building MOCK report")
        # produce mock data
        mock_index = {"close":1285.3, "pct":0.42}
        mock_vn30 = {"close":1312.8, "pct":0.37}
        mock_foreign = {"buy":1_520_000_000, "sell":1_200_000_000, "net":320_000_000}
        lines.append(f"üìà VN-Index: {mock_index['close']:.2f} ({mock_index['pct']:+.2f}%) | GTGD: {fm_money_million(18_450_000_000)}")
        lines.append(f"üìâ VN30: {mock_vn30['close']:.2f} ({mock_vn30['pct']:+.2f}%) | GTGD VN30: {fm_money_million(9_820_000_000)}")
        lines.append(f"üîÅ Kh·ªëi ngo·∫°i (to√†n TT): Mua {fm_money_million(mock_foreign['buy'])} / B√°n {fm_money_million(mock_foreign['sell'])} ‚Üí R√≤ng {fm_money_million(mock_foreign['net'])}")
        lines.append("üìä Breadth (VN30): ‚Üë 20 / ‚Üì 10")
        lines.append("üî• Top ng√†nh: Banking, Steel, RealEstate")
    else:
        try:
            # Index info
            idx_df = vn_index("VNINDEX")
            # try to extract last close and pct (adapt to returned df/series format)
            try:
                idx_last = float(idx_df['close'].iloc[-1]) if hasattr(idx_df, '__getitem__') and 'close' in idx_df.columns else float(idx_df.iloc[-1]['close'])
                idx_pct = float(idx_df['pct_change'].iloc[-1]) if 'pct_change' in idx_df.columns else None
            except Exception:
                # fallback: try different keys or series
                idx_last = None; idx_pct = None
            lines.append(f"üìà VN-Index: {idx_last if idx_last else '‚Äî'} ({idx_pct:+.2f}% if idx_pct else '‚Äî')")
            # VN30
            try:
                vn30_df = vn_index("VN30")
                vn30_last = float(vn30_df['close'].iloc[-1]) if 'close' in vn30_df.columns else None
                vn30_pct = float(vn30_df['pct_change'].iloc[-1]) if 'pct_change' in vn30_df.columns else None
                lines.append(f"üìâ VN30: {vn30_last if vn30_last else '‚Äî'} ({vn30_pct:+.2f}% if vn30_pct else '‚Äî')")
            except Exception:
                pass
            # foreign market-level
            try:
                fr = vn_foreign(None)
                fb = fr.get('buy') or fr.get('buy_value') or fr.get('buy_total') or None
                fs = fr.get('sell') or fr.get('sell_value') or fr.get('sell_total') or None
                fn = fr.get('net') or (fb - fs if fb is not None and fs is not None else None)
                lines.append(f"üîÅ Kh·ªëi ngo·∫°i (to√†n TT): Mua {fm_money_million(fb)} / B√°n {fm_money_million(fs)} ‚Üí R√≤ng {fm_money_million(fn)}")
            except Exception as e:
                dbg(f"foreign market-level failed: {e}")
        except Exception as e:
            dbg(f"vnstock index fetch failed: {e}")
            lines.append("üìà VN-Index: ‚Äî (l·ªói d·ªØ li·ªáu)")
    lines.append("")

    # Part 2 - per symbol details
    lines.append("üìå Chi ti·∫øt m√£:")
    for s in SYMBOLS:
        if vns is None or not USE_VNSTOCK:
            # mock per-symbol
            mock = {
                "MBB": {"price":28250,"pct":2.36,"vol":121_513_479,"avg5_price":27100,"avg5_vol":50_000_000,"foreign_buy":1_200_000_000,"foreign_sell":400_000_000},
                "HPG": {"price":28000,"pct":-0.71,"vol":108_066_934,"avg5_price":28500,"avg5_vol":60_000_000,"foreign_buy":300_000_000,"foreign_sell":950_000_000},
                "SSI": {"price":36550,"pct":-0.68,"vol":58_531_482,"avg5_price":36300,"avg5_vol":40_000_000,"foreign_buy":150_000_000,"foreign_sell":200_000_000},
                "PVP": {"price":15250,"pct":0.0,"vol":460_338,"avg5_price":15000,"avg5_vol":1_000_000,"foreign_buy":0,"foreign_sell":0},
                "KSB": {"price":19700,"pct":-2.72,"vol":5_053_876,"avg5_price":20400,"avg5_vol":1_000_000,"foreign_buy":20_000_000,"foreign_sell":500_000_000},
                "QTP": {"price":None,"pct":None,"vol":None,"avg5_price":None,"avg5_vol":None,"foreign_buy":None,"foreign_sell":None}
            }
            info = mock.get(s, {})
            price = info.get("price")
            pct = info.get("pct")
            vol = info.get("vol")
            avg_price = info.get("avg5_price")
            avg_vol = info.get("avg5_vol")
            fb = info.get("foreign_buy"); fs = info.get("foreign_sell")
            lines.append(f"{s}: {price if price else '‚Äî'} {fm_pct(pct)} | KL={fm_shares_million(vol)} | TB tu·∫ßn: {avg_price if avg_price else '‚Äî'} / {fm_shares_million(avg_vol)} | NN: Mua {fm_money_million(fb)} / B√°n {fm_money_million(fs)}")
        else:
            try:
                q = vn_quote(s)
                # try locate last price and percent keys
                price = None
                pct = None
                vol = None
                if isinstance(q, dict):
                    # common keys
                    for key in ("lastPrice","last_price","price","close","last"):
                        if key in q:
                            price = q.get(key); break
                    for key in ("percentChange","percent_change","pctChange","pct_change","changePercent"):
                        if key in q:
                            pct = q.get(key); break
                    for key in ("nmVol","volume","vol","totalVolume"):
                        if key in q:
                            vol = q.get(key); break
                else:
                    # if q is a pandas series or dataframe row-like
                    try:
                        if hasattr(q,'to_dict'):
                            d = q.to_dict()
                            price = d.get('lastPrice') or d.get('close') or d.get('last')
                            pct = d.get('percentChange') or d.get('pct_change') or d.get('changePercent')
                            vol = d.get('nmVol') or d.get('volume') or d.get('vol')
                        else:
                            price = float(q)
                    except Exception:
                        pass
                # history -> avg 5 close & avg vol20
                try:
                    end = datetime.now().strftime("%Y-%m-%d")
                    start = (datetime.now() - timedelta(days=21)).strftime("%Y-%m-%d")
                    hist = vn_history(s, start_date=start, end_date=end, resolution="1D")
                    # normalize to pandas dataframe
                    if hasattr(hist, 'to_pandas'):
                        df = hist.to_pandas()
                    elif hasattr(hist, 'iloc') or isinstance(hist, (pd.DataFrame, pd.Series)):
                        df = hist if isinstance(hist, pd.DataFrame) else hist.to_frame().T
                    else:
                        df = pd.DataFrame(hist)
                    # adapt if columns names vary
                    # compute avg5 and avgvol20
                    if not df.empty:
                        # try common close col names
                        cols = {c.lower():c for c in df.columns}
                        close_col = cols.get('close') or cols.get('close_price') or cols.get('last') or list(df.columns)[0]
                        vol_col = cols.get('volume') or cols.get('vol') or cols.get('nmvol') or (list(df.columns)[1] if len(df.columns)>1 else None)
                        avg5 = df[close_col].tail(5).mean() if close_col in df.columns else None
                        avgvol20 = df[vol_col].tail(20).mean() if vol_col in df.columns else None
                    else:
                        avg5 = avgvol20 = None
                except Exception as e:
                    dbg(f"history fetch failed for {s}: {e}")
                    avg5 = avgvol20 = None
                # foreign flows per symbol
                try:
                    fr = vn_foreign(s)
                    fb = fr.get('buy') or fr.get('buy_value') or fr.get('buy_total') or None
                    fs = fr.get('sell') or fr.get('sell_value') or fr.get('sell_total') or None
                except Exception as e:
                    dbg(f"foreign fetch failed for {s}: {e}")
                    fb = fs = None
                lines.append(f"{s}: {price if price else '‚Äî'} {fm_pct(pct)} | KL={fm_shares_million(vol)} | TB tu·∫ßn: {avg5 if avg5 else '‚Äî'} / {fm_shares_million(avgvol20)} | NN: Mua {fm_money_million(fb)} / B√°n {fm_money_million(fs)}")
            except Exception as e:
                dbg(f"Failed building line for {s}: {e}")
                lines.append(f"{s}: ‚Äî (l·ªói d·ªØ li·ªáu)")
    # Alerts summary (basic)
    lines.append("")
    lines.append("‚ö†Ô∏è Alerts:")
    for s in SYMBOLS:
        # For simplicity check mock or real computed rows in previous loop by parsing lines - or recompute quickly
        pass
    lines.append("")
    lines.append(f"(Th·ªùi gian b√°o c√°o: {now}) - Bot_vnstock")
    return "\n".join(lines)

# Telegram send helper (with chunking)
def chunk_text(s: str, limit: int = 3500):
    s = s or ""
    if len(s) <= limit:
        return [s]
    chunks = []
    cur = s
    while len(cur) > limit:
        cut = cur.rfind("\n", 0, limit)
        if cut == -1:
            cut = limit
        chunks.append(cur[:cut])
        cur = cur[cut:]
    if cur:
        chunks.append(cur)
    return chunks

def send_to_telegram(text: str):
    if not BOT_TOKEN or not CHAT_ID:
        dbg("BOT_TOKEN or CHAT_ID missing - not sending to Telegram")
        print(text)
        return False
    if requests is None:
        dbg("requests library not available - cannot send to Telegram, printing instead")
        print(text)
        return False
    base_url = f"https://api.telegram.org/bot{BOT_TOKEN}/sendMessage"
    dbg(f"Preparing to send to Telegram. CHAT_ID={CHAT_ID}, TOKEN=***{BOT_TOKEN[-6:]}")
    parts = chunk_text(text, 3500)
    all_ok = True
    for i, part in enumerate(parts, 1):
        payload = {"chat_id": CHAT_ID, "text": part, "disable_web_page_preview": True}
        try:
            dbg(f"Sending chunk {i}/{len(parts)} (len={len(part)}) ...")
            r = requests.post(base_url, data=payload, timeout=20)
            dbg(f"Telegram response: {r.status_code} {r.text[:500]}")
            if r.status_code != 200:
                all_ok = False
        except Exception as e:
            dbg(f"Error sending chunk {i}: {e}")
            all_ok = False
    return all_ok

def main():
    try:
        report = build_report()
        print("=== Report preview ===")
        print(report)
        # Always try to send (user's environment should have BOT_TOKEN/CHAT_ID set)
        ok = send_to_telegram(report)
        if ok:
            dbg("Report sent to Telegram (or attempted).")
        else:
            dbg("Report not sent (see logs).")
    except Exception as e:
        print("Fatal error in main:", e)
        traceback.print_exc()

if __name__ == "__main__":
    main()
